<?php

class Batch_YouTube_Uploader {

	/**
	 * Array of arrays
	 * Generated by .csv file
	 */
	var $csvArray = array();

	/**
	 * The directory the videos are stored in
	 */
	var $videoDir;

	/**
	 * Logfile output
	 * Currently, we're writing to a new file
	 * @todo write back to input file, use this as actual log
	 */
	var $logFile = 'completed.csv';

	/**
	 * Google client
	 */
	var $client;

	/**
	 * YouTube client
	 */
	var $youtube;

	/**
	 * YouTube scopes for authorization
	 */
	var $scopes = array(
		'https://www.googleapis.com/auth/youtube',
		'https://www.googleapis.com/auth/youtube.upload',
		'https://www.googleapis.com/auth/youtubepartner'
		);

	public function __construct($csv) {
		$this->csvArray = $this->csvToArray($csv);

		$this->client = new Google_Client();
		$this->client->setClientId(getenv('oauth2_client_id'));
		$this->client->setClientSecret(getenv('oauth2_client_secret'));
		$this->client->setRedirectUri(getenv('oauth2_redirect_uri'));
		$this->client->setScopes($this->scopes);

		$this->videoDir = getenv('videodir');
	}

	/**
	 * Converts .csv file to an array of arrays
	 *
	 * @link http://gist.github.com/385876
	 * @return csvArray (array of arrays)
	 */
	protected function csvToArray($filename='', $delimiter=',') {
		ini_set('auto_detect_line_endings',TRUE);
		if(!file_exists($filename) || !is_readable($filename))
			return FALSE; // @todo maybe throw Exception here instead?

		$header = NULL;
		$data = array();
		if (($handle = fopen($filename, 'r')) !== FALSE) {
			while (($row = fgetcsv($handle, 1000, $delimiter)) !== FALSE) {
				if (!$header) {
					$header = $row;
				} else {
					if (count($header) > count($row)) {
						$difference = count($header) - count($row);
						for ($i = 1; $i <= $difference; $i++) {
							$row[count($row) + 1] = $delimiter;
						}
					}
					$data[] = array_combine($header, $row);
				}
			}
			fclose($handle);
		}
		return $data;
	}


	/**
	 * Login and authenticate with Google
	 *
	 * @access public
	 * @return void
	 */
	public function login() {
		// @todo need to check if token is written somewhere and use that if it's still active
		// For now, we're going to request a new token every time we run the script
		$authUrl = $this->client->createAuthUrl();

		`open '$authUrl'`;
		echo "\nPlease enter the auth code:\n";
		$authCode = trim(fgets(STDIN));

		$accessToken = $this->client->authenticate($authCode);
		// @todo write token somewhere for future use?
		// @todo get access token that doesn't expire in only an hour

		$this->youtube = new Google_Service_YouTube($this->client);
	}

	public function process() {
		foreach($this->csvArray as $videoInfo) {
			$videoPath = $this->videoDir . '/' . $videoInfo['filename'];
			if(!file_exists($videoPath)) {
				$logData = $videoInfo['entry_id'] . ',' . '"' . $videoInfo['title'] . '"' . ',' . $videoInfo['filename'] . ',' . "File does not exist\n";
				file_put_contents($this->logFile, $logData, FILE_APPEND | LOCK_EX);
				continue;
			}
			if(!empty($videoInfo['youtube_url'])) {
				$logData = $videoInfo['entry_id'] . ',' . '"' . $videoInfo['title'] . '"' . ',' . $videoInfo['filename'] . ',' . $videoInfo['youtube_url'] . "\n";
				file_put_contents($this->logFile, $logData, FILE_APPEND | LOCK_EX);
				continue;
			}
			try {
				$startTime = time();
				// Create a snippet with title, description, tags and category ID
				// Create an asset resource and set its snippet metadata and type.
				print "Uploading {$videoInfo['title']}\n";
				$snippet = new Google_Service_YouTube_VideoSnippet();
				$snippet->setTitle($videoInfo['title']);
				// $snippet->setDescription($videoInfo['description']);
				$snippet->setCategoryId("28"); // @todo make this selectable in some way; 28 = Science & Technology

				// Set the video's status to "unlisted".
				$status = new Google_Service_YouTube_VideoStatus();
				$status->privacyStatus = "unlisted";

				// Associate the snippet and status objects with a new video resource.
				$video = new Google_Service_YouTube_Video();
				$video->setSnippet($snippet);
				$video->setStatus($status);

				// Specify the size of each chunk of data, in bytes. Set a higher value for
				// reliable connection as fewer chunks lead to faster uploads. Set a lower
				// value for better recovery on less reliable connections.
				// @todo How can we set the chuckSize more efficiently?
				$chunkSizeBytes = 1 * 1024 * 1024;

				// Setting the defer flag to true tells the client to return a request which can be called
				// with ->execute(); instead of making the API call immediately.
				$this->client->setDefer(true);

				// Create a request for the API's videos.insert method to create and upload the video.
				$insertRequest = $this->youtube->videos->insert("status,snippet", $video);

				// Create a MediaFileUpload object for resumable uploads.
				$media = new Google_Http_MediaFileUpload(
					$this->client,
					$insertRequest,
					'video/*',
					null,
					true,
					$chunkSizeBytes
					);
				$filesize = filesize($videoPath);
				$media->setFileSize($filesize);

				// Read the media file and upload it chunk by chunk.
				$status = false;
				$handle = fopen($videoPath, "rb");
				while (!$status && !feof($handle)) {
					$chunk = fread($handle, $chunkSizeBytes);
					$status = $media->nextChunk($chunk); // @todo deal with exception
					$currentProgress = $media->getProgress();
					$progressPercentage = ($currentProgress/$filesize) * 100;
					print($progressPercentage . "%\n");
				}

				fclose($handle);

				// If you want to make other calls after the file upload, set setDefer back to false
				$this->client->setDefer(false);
				print $videoInfo['title'] . " uploaded\n";
				print "https://www.youtube.com/watch?v=" . $status->id . "\n";
				$logData = $videoInfo['entry_id'] . ',' . '"' . $videoInfo['title'] . '"' . ',' . $videoInfo['filename'] . ',' . "https://www.youtube.com/watch?v={$status->id}\n";
				file_put_contents($logFile, $logData, FILE_APPEND | LOCK_EX);
			} catch(Google_Exception $e) {
				$exceptionMsg = "Google service Exception: " . $e->getCode() . "; message: "	. $e->getMessage();
				print($exceptionMsg);
				exit('Likely need to refresh the token');
			}
		}
	}
}